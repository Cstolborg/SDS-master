---
title: 'Advanced Network Analysis: Bipartite (2-mode) netwpoks: Application (R)'
author: "Daniel S. Hain (dsh@business.aau.dk)"
date: "Updated `r format(Sys.time(), '%B %d, %Y')`"
output:
  html_notebook:
    code_folding: show
    df_print: paged
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
    theme: flatly
---

```{r setup, include=FALSE}
### Generic preamble
rm(list=ls())
Sys.setenv(LANG = "en") # For english language
options(scipen = 5) # To deactivate annoying scientific number notation

### Knitr options
library(knitr) # For display of the markdown
knitr::opts_chunk$set(warning=FALSE,
                     message=FALSE,
                     comment=FALSE, 
                     fig.align="center"
                     )
```

```{r}
### Load standardpackages
library(tidyverse) # Collection of all the good stuff like dplyr, ggplot2 ect.
library(magrittr) # For extra-piping operators (eg. %<>%)

library(tidygraph)
library(ggraph)
library(igraph)
```


In this session, you will learn:

1. What are alternative ways to create network structures.
2. What are different options to visualize networks and highlight properties.
3. How to analyse multi-modal networks.

# Types of networks

We up to now already talked about different ways how networks can be constructed. Up to now, we mainly focussed on:

* Interaction between entities
* Co-occurence

However, network analysis and modelling is also fully consistent with other structures, which are often a natural outcome of supervised or unsupervised ML exercises:

* Similarities
* Hirarchies (tree-structures)

## Similarity networks

Since similarity is a relational property between entities, similarity matrices obviously can be modeled as a network. Lets illustrate that at the classican `mtcars` example.

```{r}
mtcars %>% head() 
```

Whe could first run a PCA to reduce the dimensionality of the numerical data.

```{r}
cars_pca <- mtcars[,c(1:7,10,11)] %>% 
  drop_na() %>%
  prcomp(center = TRUE , scale = TRUE)
```

Next, we could create a distance matrice (using the `dist()`) function.

```{r}
cars_dist <- cars_pca$x %>% dist(method = "euclidean") 
```

La voila. Such a distance matrix representas a relational structure and can be modelled as a network.

```{r}
g <- cars_dist %>% 
  as.matrix() %>%
  as_tbl_graph(directed = FALSE) 
```

```{r}
g <- g %>% simplify() %>% as_tbl_graph()
```

```{r}
g
```


Since the network is based on a distance matrix, we would like to reverse that to get edges representing similarity. Since similarity structures are usually fully connected networks, we probably also want to create some sparsity by deleting lower quantile edge weights.

```{r}
g <- g %E>%
  mutate(weight = max(weight) - weight) %>%
  filter(weight >= weight %>% quantile(0.75)) %N>%
  filter(!node_is_isolated()) %>%
  mutate(community = group_louvain(weights = weight) %>% factor())
```

Lets take a look!

```{r}
set.seed(1337)
g %>% ggraph(layout = "nicely") + 
  geom_node_point(aes(col = community, size = centrality_degree(weights = weight))) + 
  geom_edge_link(aes(width = weight), alpha = 0.25) +
  scale_edge_width(range = c(0.1, 2)) + 
  geom_node_text(aes(label = name, filter = percent_rank(centrality_degree(weights = weight)) > 0.5), repel = TRUE) +
  theme_graph() + 
  theme(legend.position = 'bottom')
```


## Hierarchy (tree) networks

Hirarchical structures are obviously also relational. The difference is, that the connectivity structure tends to be constraint to other levels.

```{r}
create_tree(20, 3) %>% 
    mutate(leaf = node_is_leaf(), root = node_is_root()) %>% 
    ggraph(layout = 'tree') +
    geom_edge_diagonal() +
    geom_node_point(aes(filter = leaf), colour = 'forestgreen', size = 10) +
    geom_node_point(aes(filter = root), colour = 'firebrick', size = 10) +
    theme_graph()
```

* In addition to real life examples such as organigrams, evolutionary trees etc., many ML models result in tree-structures (eg. decision trees).
* We will at our car example execute a hierarchical clustering, which leads to a tree structure (visualized in the dendogram).

```{r}
cars_hc <- cars_dist %>%
  hclust(method = "ward.D2")
```

Again, this structure can be directly transfered to a graph object.

```{r}
g <- cars_hc %>% as_tbl_graph()
```

```{r}
g
```


```{r}
g %>% ggraph(layout = 'dendrogram') + 
  geom_edge_diagonal(aes(col = .N()$height[from])) +
  geom_node_point(aes(col =height)) +
  geom_node_text(aes(filter = leaf, label = label), angle=90, hjust=1, nudge_y=-0.1) + 
  theme_graph() + 
  ylim(-0.6, NA) 
```




# Multi-Modal Networks

## Intuition

Now its time to talk about an interesting type of networks, multi-modal. This means, a network has several "modes", meaning connects entities on different conceptual levels. The most common one is a **2-mode** (or **bipartite**) network. Examples could be an Author $\rightarrow$ Paper, Inventor $\rightarrow$ Patent, Member $\rightarrow$ Club network. Here, the elements in the different modes represent different things. 

We can alalyse them in seperation (and sometimes we should), but often its helpful to "project"" them onto one mode. Here, we create a node in one mode by joint association with another mode.

![](https://sds-aau.github.io/SDS-master/00_media/networks_2mode.png){width=500px}

While that sounds simple, it can be a very powerful technique, as I will demonstrate now.

```{r}
set.seed(1337)
g <- create_bipartite(4, 10, directed = TRUE, mode = "out") %E>%
  sample_n(15)
```

```{r}
people <- c('Jesper', 'Pernille', 'Morten', 'Lise', 'Christian', 'Mette', 'Casper', 'Dorte', 'Jacob', 'Helle')
places <- c('Yoga House', 'Crossfit', 'Jazz Club', 'Jomfru Anne Gade')
```

```{r}
g <- g %N>%
  mutate(name = c(places, people))
```


```{r}
g %>% ggraph("bipartite") + 
  geom_edge_link(alpha = 0.25) + 
  geom_node_point(aes(col = type, size = centrality_degree(mode = 'all'))) + 
  geom_node_text(aes(label = name), repel = TRUE) + 
  theme_graph() +
  theme(legend.position = 'none')
```
TODO: A bit more





```{r}
## Helper function
el_to_sparse_matrix <- function(data, # the edgelist
                                mode_1, # which variable indicates mode 1
                                mode_2, # which variable indicates mode 2
                                projection = 'none' # If a pojection should be done, possible is 'none', 'mode1', 'mode2' 
                                ){
  
  # Define inputs
  i_input <- data %>% pull({{mode_1}}) 
  j_input <- data %>% pull({{mode_2}}) 
  
  require(Matrix)
  mat <- spMatrix(nrow = i_input %>% n_distinct(),
                  ncol = j_input %>% n_distinct(),
                  i = i_input %>% factor() %>% as.numeric(),
                  j = j_input %>% factor() %>% as.numeric(),
                  x = rep(1, i_input %>% length() ) )
  
  row.names(mat) <- i_input %>% factor() %>% levels()
  colnames(mat) <- j_input %>% factor() %>% levels()
  
  # Projection if necessary
  if(projection == 'mode1'){mat %<>% tcrossprod()}
  if(projection == 'mode2'){mat %<>% crossprod()}  
    
  return(mat)
}
```



* creating 2-mode networks

# Case study: Bibliographic networks

## Basics

Lets talk about bibliographic networks. In short, that are networks between documents which cite each others. That can be (commonly) academic publications, but also patents or policy reports. Conceptually, we can see them as 2 mode networks, between articles and their reference. That helps us to apply some interesting metrics, such as:

* direct citations
* Bibliographic coupling
* Co--citations

Interestingly, different projections of this 2-mode network give the whole resulting 1-mode network a different meaning.

![](https://sds-aau.github.io/SDS-master/00_media/networks_biblio.png){width=500px}


I will illustrate more in detail in the following. The example is based on some own work.[^1]

## The DATA

Lets imagine we do it the hard way. We download some bibliographic data, and have to do all the munging on our own, till we end up with a nice network representation. Lets go through some of these steps together.

`TITLE-ABS-KEY ( "network analysis" )  AND  ( LIMIT-TO ( DOCTYPE ,  "ar" )  OR  LIMIT-TO ( DOCTYPE ,  "cp" ) )  AND  ( LIMIT-TO ( LANGUAGE ,  "English" ) )  AND  ( LIMIT-TO ( SRCTYPE ,  "j" )  OR  LIMIT-TO ( SRCTYPE ,  "p" ) )  AND  ( LIMIT-TO ( PUBYEAR ,  2021 )  OR  LIMIT-TO ( PUBYEAR ,  2020 )  OR  LIMIT-TO ( PUBYEAR ,  2019 )  OR  LIMIT-TO ( PUBYEAR ,  2018 )  OR  LIMIT-TO ( PUBYEAR ,  2017 )  OR  LIMIT-TO ( PUBYEAR ,  2016 )  OR  LIMIT-TO ( PUBYEAR ,  2015 ) ) `

```{r}
rm(list=ls())
data <- read_csv('https://github.com/SDS-AAU/SDS-master/raw/master/00_data/networks_bibliometrics/biblio_nw.csv')
```

```{r}
data %>%
  glimpse()
```

## Preprocessing

```{r}
data %<>%
  select(EID, Authors, `Author(s) ID`, Title, `Abbreviated Source Title`, Year, Affiliations, `Author Keywords`, `Cited by`, Abstract, References) %>%
  rename(author = Authors,
         author_id = `Author(s) ID`,
         title = Title,
         journal = `Abbreviated Source Title`,
         year = Year,
         affiliation = Affiliations,
         keywords = `Author Keywords`,
         citations = `Cited by`,
         Abstract = Abstract,
         references = References)
```


```{r}
data[2, 'author']
```

```{r}
data[2, 'author_id']
```

```{r}
data[2, 'affiliation']
```

```{r}
data[2, "keywords"]
```

```{r}
data[2, "references"]
```

```{r}
data %<>% 
  mutate(author = author %>% str_split(', '),
         author_id = author_id %>% str_split(';'),
         affiliation = affiliation %>% str_split(';'),
         keywords = keywords %>% str_split('; '),
         references = references %>% str_split('; '))
```


```{r}
data %>% select(title, author, citations) %>% 
  unnest(author) %>%
  head()
```

```{r}
data %>% select(title, author, citations) %>% 
  unnest(author) %>%
  group_by(author) %>%
  summarise(n = n(),
            citations = citations %>% sum(na.rm = TRUE)) %>%
  arrange(desc(citations)) %>%
  head(10)
```
## Bipartite Network Generation

I will now transfer them to an article $\rightarrow$ reference edgelist.

```{r}
el_2m <- data %>% select(EID, references) %>% unnest(references) 
```

```{r}
el_2m %>% head()
```

## Bibliographic Coupling

* We now need to create a projection of the 2-mode matrix to one of the modes.
* We could do that more efficiently via using the sparse matrix calculation I did before, but for maximum clarity lets do it via a join.
* We will first create the article to article network.

```{r}
el_bib <- el_2m %>% left_join(el_2m, by = 'references') %>%
  rename(from = EID.x, 
         to = EID.y) %>%
  select(from, to) %>%
  filter(from != to) %>%
  count(from, to, name = 'weight')
```

```{r}
el_bib %>% head()
```

```{r}
el_bib %>% 
  ggplot(aes(x = weight)) +
  geom_histogram()
```
```{r}
el_bib %<>%
  filter(weight >=3)
```

```{r}
el_bib %>% 
  ggplot(aes(x = weight)) +
  geom_histogram()
```
* Ok, great, we now can create a graph

```{r}

```






